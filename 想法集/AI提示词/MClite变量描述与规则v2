<description>
# MClite 变量结构说明 v2.1

本文档描述 MClite 系统的变量结构，采用 Schema-Driven 可扩展架构。
变量根路径: `MC`

---

# 系统变量
路径: `MC.系统`

当前地点: 当前场景所在位置
当前时间: 包含日期和精确时间的时间对象
- 日期: 格式为"YYYY年M月D日"
- 时间: 24小时制时间，格式为"HH:MM"（如"09:30"、"14:00"、"23:45"）

说明: 系统变量记录全局状态信息。时间采用24小时制便于AI进行时间计算和推进。所有字段均可根据世界观需要自定义扩展。

---

# 玩家变量
路径: `MC.玩家`

姓名: 玩家角色的姓名
年龄: 玩家角色的年龄（数字）
职位: 玩家角色的职位名称
部门: 玩家角色所属的部门

说明: 玩家变量记录玩家角色的基本信息。这些信息用于AI进行角色扮演和剧情推进。

---

# 花名册（Schema-Driven 结构）
路径: `MC.花名册`

花名册采用 Schema-Driven 架构，支持完全自定义的字段结构。由三部分组成：
1. `$meta` - 元信息（标记可扩展性）
2. `$schema` - 结构定义（定义字段、分组）
3. `entries` - 实际数据条目

## $schema 配置
格式: `"$schema": { "primaryKey": "主键字段名", "displayField": "显示字段名", "groupByField": "分组字段名", "fields": { "$meta": { "extensible": true }, ... }, "groups": { "$meta": { "extensible": true }, ... } }`

说明: $schema 定义花名册的数据结构。所有配置项均为可选，可根据需要添加。
- primaryKey: 用于唯一标识条目的字段名
- displayField: 用于列表展示的字段名
- groupByField: 用于分组显示的字段名
- fields: 字段定义集合，可扩展
- groups: 字段分组定义，可扩展

## fields 字段定义
格式: `"字段ID": { "label": "显示名称", "type": "字段类型", "description": "字段描述", "showInList": true/false, "showInSummary": true/false, "order": 数字, "options": [], "default": 默认值 }`

说明: 定义花名册中的字段。每个字段使用唯一ID作为键。
- label: 字段的显示名称
- type: 字段类型，支持 string/number/text/enum/tags/boolean 等
- description: 字段描述，用于提示AI理解字段用途
- showInList: 是否在列表视图显示
- showInSummary: 是否在摘要卡片显示
- order: 显示顺序，数字越小越靠前
- options: 当type为enum时的可选值列表
- default: 字段的默认值

## groups 分组定义
格式: `"分组ID": { "label": "分组名称", "order": 数字, "collapsed": true/false, "fields": ["字段ID1", "字段ID2", ...] }`

说明: 定义字段的分组方式。每个分组使用唯一ID作为键。
- label: 分组的显示名称
- order: 分组显示顺序
- collapsed: 是否默认折叠
- fields: 包含的字段ID列表

## entries 数据条目
格式: `"条目ID": { "字段1": 值, "字段2": 值, ... }`

说明: 存放实际的数据条目。以条目ID为键，值为包含所有字段数据的对象。条目的字段应与 $schema.fields 中定义的字段对应。

⚠️ **重要：键名不能包含点号（.）！** 因为点号是路径分隔符。
- ❌ 错误：`"No.001"` - 会被解析为 `No` -> `001` 两级路径
- ✅ 正确：`"No001"` 或 `"No_001"` 或 `"员工001"`

---

# 文档（多文档并行 + 递归树形结构）
路径: `MC.文档`

文档容器支持多份文档并行存在，每份文档采用统一节点类型的递归树形结构。

## 文档容器
格式: `"MC.文档": { "$meta": { "extensible": true, "template": { "title": "", "description": "", "order": 0, "sections": { "$meta": { "extensible": true } } } }, "文档名称1": { ... }, "文档名称2": { ... } }`

说明: 文档容器是可扩展的对象，使用文档名称作为键。$meta.template 定义了新文档应遵循的结构模板。

## 单份文档结构
格式: `"文档名称": { "title": "文档标题", "description": "文档描述", "order": 排序数字, "sections": { "$meta": { "extensible": true }, "节点ID": { ... }, ... } }`

说明: 每份文档包含标题、描述、排序和节点集合。sections 为可扩展对象。
- title: 文档的标题
- description: 文档的描述信息
- order: 文档在列表中的排序
- sections: 节点集合，可扩展

## section 节点结构
格式: `"节点ID": { "title": "节点标题", "content": "节点内容", "order": 排序数字, "children": { "$meta": { "extensible": true }, ... } }`

说明: 节点采用递归结构，每个节点可包含子节点，支持任意层级嵌套。
- title: 节点的标题
- content: 节点的正文内容（可为空）
- order: 节点在同级中的排序
- children: 子节点集合，可扩展，结构与父节点相同

---

# 可扩展性机制

## $meta.extensible
所有带有 `"$meta": { "extensible": true }` 的对象都支持动态添加新键值对。这是系统可扩展性的核心标记。

## $meta.template
带有 `template` 的 `$meta` 表示该对象的新条目应遵循 template 中定义的结构。

示例:
```json
"fields": {
  "$meta": {
    "extensible": true,
    "template": {
      "label": "",
      "type": "string",
      "description": ""
    }
  }
}
```

说明: 表示可以向 fields 中添加新字段，新字段应包含 label、type、description 等属性。template 仅作为参考模板，实际添加时可根据需要增减属性。

---

# 自定义扩展说明

本系统设计的核心理念是**高度可扩展性**：

1. **字段可自定义**: 花名册的字段完全由 $schema.fields 定义，可随时添加新字段
2. **分组可自定义**: 字段分组由 $schema.groups 定义，可随时重组字段
3. **文档可并行**: 文档容器支持同时存在多份不同的文档
4. **结构可嵌套**: 文档节点支持无限层级递归嵌套
5. **系统可扩展**: MC 根对象本身也是可扩展的，可添加全新的顶级模块

</description>


<变量更新规则>
严格按照以下规则和格式进行输出，并确定哪个变量是否需要更新，禁止额外添加标签：

rule:
  description:
    - 根据叙事内容分析需要更新的变量，在响应末尾输出变量更新指令
    - 可用指令共4个：`_.set`、`_.assign`、`_.remove`、`_.add`
    - _.set: 设置值，支持2-3个参数（仅用于修改已存在的值）
    - _.assign: 向对象添加新键值对，支持2-3个参数（用于创建新条目或添加新属性）
    - _.remove: 从对象删除键，支持1-2个参数
    - _.add: 数值增减，仅支持2个参数，仅用于数字类型
    - 如需添加或删除多个值，需多次调用指令
    - 数字参数支持数学表达式
  
  ## ⚠️⚠️⚠️ 关键约束（必须严格遵守，违反将导致错误）⚠️⚠️⚠️
  
  ### 🚨🚨🚨 最重要的约束：键名不能包含点号！🚨🚨🚨
  
  **点号（.）是路径分隔符**，如果键名中包含点号，会导致路径解析错误！
  
  | 写法 | 结果 | 说明 |
  |------|------|------|
  | `_.assign('MC.花名册.entries', 'No.001', {...})` | ❌ 错误 | `No.001` 会被解析为两级路径 |
  | `_.assign('MC.花名册.entries', 'No001', {...})` | ✅ 正确 | 使用无点号的键名 |
  | `_.set('MC.花名册.entries.No.001.name', ...)` | ❌ 错误 | 路径会被错误解析 |
  | `_.set('MC.花名册.entries.No001.name', ...)` | ✅ 正确 | 使用无点号的键名 |
  
  **正确的键名格式**：
  - `No001`、`No002`、`No003` ✅
  - `员工001`、`角色A` ✅
  - `No_001`、`entry-001` ✅
  
  **错误的键名格式**：
  - `No.001` ❌（点号会被解析为路径分隔符）
  - `1.2.3` ❌（多个点号更危险）
  
  ### 核心原则：_.set 和 _.assign 的本质区别
  
  | 指令 | 用途 | 路径要求 |
  |------|------|----------|
  | `_.assign(父路径, 键名, 值)` | 在父对象中创建/覆盖一个键 | 父路径必须存在且是对象 |
  | `_.set(完整路径, 旧值, 新值)` | 修改已存在的值 | 完整路径必须已存在 |
  
  ### 🚨 条目操作的黄金法则（最重要！）
  
  **创建/覆盖整个条目** → 使用 `_.assign`，路径到 `entries`：
  ```javascript
  // ✅ 正确：在 entries 下创建条目 No001（注意键名不含点号）
  _.assign('MC.花名册.entries', 'No001', { "id": "No001", "name": "xxx", ... });
  ```
  
  **修改条目内的单个字段** → 使用 `_.set`，路径到具体字段：
  ```javascript
  // ✅ 正确：修改已存在条目的某个字段（前提是 No001 已存在）
  _.set('MC.花名册.entries.No001.name', '旧名字', '新名字');
  ```
  
  ### ❌ 常见错误（会导致 "path does not exist" 错误）
  
  ```javascript
  // ❌ 错误：用 _.set 去"更新"一个不存在的条目
  _.set('MC.花名册.entries.No001', {...}, {...});  // 如果 No001 不存在，会失败！
  
  // ❌ 错误：用 _.set 去修改不存在条目的字段
  _.set('MC.花名册.entries.No001.name', null, '张三');  // 如果 No001 不存在，会失败！
  
  // ❌ 错误：用 _.assign 在不存在的条目上添加字段
  _.assign('MC.花名册.entries.No001', 'name', '张三');  // 如果 No001 不存在，会失败！
  
  // ❌ 错误：键名包含点号（会导致路径解析错误）
  _.assign('MC.花名册.entries', 'No.001', {...});  // 点号会被解析为路径分隔符！
  ```
  
  ### ✅ 正确做法总结
  
  | 场景 | 正确写法 |
  |------|----------|
  | 创建新条目 | `_.assign('MC.花名册.entries', 'No004', { 完整对象 });` |
  | 覆盖已有条目（改很多字段） | `_.assign('MC.花名册.entries', 'No001', { 新的完整对象 });` |
  | 修改条目的单个字段 | `_.set('MC.花名册.entries.No001.字段名', 旧值, 新值);` |
  | 🚨为条目添加新字段🚨 | **必须用 `_.assign` 覆盖整个条目，包含所有旧字段 + 新字段！** |
  
  ### 🚨🚨🚨 超级重要：为已存在条目添加新字段的正确方法 🚨🚨🚨
  
  **MVU 框架的 schema 验证机制会阻止向已存在的条目对象直接添加新键！**
  
  ```javascript
  // ❌ 错误！会报 "SCHEMA VIOLATION: Cannot assign new key into non-extensible object"
  _.assign('MC.花名册.entries.No001', 'bust', '新字段值');
  _.assign('MC.花名册.entries.No001', 'waist', '新字段值');
  _.assign('MC.花名册.entries.No001', 'hips', '新字段值');
  
  // ✅ 正确！必须用 _.assign 覆盖整个条目，包含所有原有字段 + 新字段
  _.assign('MC.花名册.entries', 'No001', {
    // 保留所有原有字段
    "id": "No001",
    "name": "沈凌汐",
    "gender": "女",
    "age": 27,
    "department": "行动一科",
    "position": "科长",
    "rank": "管理层",
    "yearsOfService": 5,
    "appearance": "...",
    "figure": "...",
    "attire": "...",
    "personality": ["严厉", "一丝不苟"],
    "rating": "S级",
    "notes": "...",
    // 添加新字段
    "bust": "新字段值",
    "waist": "新字段值",
    "hips": "新字段值"
  });
  ```
  
  **为什么？** 因为 MVU 框架的 entries 中的每个条目对象默认不可扩展（non-extensible）。
  只有容器对象（如 `entries` 本身）带有 `$meta: { extensible: true }` 标记，才允许添加新键。
  
  **正确流程（为多个条目添加新字段时）：**
  1. 先更新 $schema.fields 添加新字段定义
  2. 先更新 $schema.groups 将新字段加入分组
  3. 然后用 `_.assign('MC.花名册.entries', '条目ID', { 完整对象包含所有旧字段+新字段 })` 覆盖每个条目
  
  analysis:
    - 数据结构与路径规则:
        - 花名册条目: 路径格式为 `MC.花名册.entries.条目ID.字段名`
        - 文档节点: 路径格式为 `MC.文档.文档名.sections.节点ID.属性名`
        - 子节点: 路径格式为 `MC.文档.文档名.sections.节点ID.children.子节点ID.属性名`
        - Schema字段: 路径格式为 `MC.花名册.$schema.fields.字段ID.属性名`
    - 操作规则:
        - 先创建后修改: 必须先用 `_.assign` 创建条目，才能对其内部属性进行修改
        - 路径精确: 修改时路径需精确到具体属性
        - 中文注释: 每条指令前用 `//` 添加中文注释说明原因
        - 非必要不删除: 除非明确需要，否免使用 `_.remove`
        - **确认存在再修改**: 使用 _.set 修改字段前，确保该条目已存在于数据中

  ## 你只能使用 _.set、_.add、_.assign、_.remove 这四个指令

  操作示例:
    - Schema操作:
        - 添加新字段定义:
          `_.assign('MC.花名册.$schema.fields', '新字段ID', { "label": "显示名称", "type": "string", "order": 10 });`
        - 修改现有字段定义:
          `_.set('MC.花名册.$schema.fields.字段ID.label', '旧名称', '新名称');`
        - 将字段加入分组:
          `_.set('MC.花名册.$schema.groups.分组ID.fields', ["旧字段1"], ["旧字段1", "新字段ID"]);`
    
    - 花名册操作:
        - 创建新条目（必须用 assign，路径到 entries）:
          `_.assign('MC.花名册.entries', '条目ID', { "id": "条目ID", "name": "姓名", "字段1": "值1", "字段2": "值2" });`
        - 覆盖/更新整个条目（也用 assign，路径到 entries）:
          `_.assign('MC.花名册.entries', '条目ID', { "id": "条目ID", "字段1": "新值1", "字段2": "新值2", ... });`
        - 修改已存在条目的单个属性（用 set，路径到具体字段）:
          `_.set('MC.花名册.entries.条目ID.字段名', '旧值', '新值');`
        - 数值增减:
          `_.add('MC.花名册.entries.条目ID.数值字段', 增量);`
        - 🚨为已存在条目添加新字段（重要！）:
          **不能用** `_.assign('MC.花名册.entries.条目ID', '新字段名', '新字段值');` ← 会报 SCHEMA VIOLATION！
          **必须用** `_.assign('MC.花名册.entries', '条目ID', { 所有原字段 + 新字段的完整对象 });`
    
    - 文档操作:
        - 添加新文档:
          `_.assign('MC.文档', '文档名', { "title": "标题", "description": "描述", "order": 1, "sections": { "$meta": { "extensible": true } } });`
        - 添加章节:
          `_.assign('MC.文档.文档名.sections', '章节ID', { "title": "章节标题", "content": "章节内容", "order": 1, "children": { "$meta": { "extensible": true } } });`
        - 添加子节点:
          `_.assign('MC.文档.文档名.sections.章节ID.children', '子节点ID', { "title": "标题", "content": "内容", "order": 1 });`
        - 修改节点内容:
          `_.set('MC.文档.文档名.sections.章节ID.content', '旧内容', '新内容');`
    
    - 系统变量操作:
        - 更新当前地点:
          `_.set('MC.系统.当前地点', '旧地点', '新地点');`
        - 更新时间（24小时制）:
          `_.set('MC.系统.当前时间.时间', '09:30', '14:00');`
        - 更新日期:
          `_.set('MC.系统.当前时间.日期', '2024年3月15日', '2024年3月16日');`
    
    - 玩家变量操作:
        - 更新玩家姓名:
          `_.set('MC.玩家.姓名', '旧姓名', '新姓名');`
        - 更新玩家年龄:
          `_.set('MC.玩家.年龄', 26, 27);`
        - 更新玩家职位:
          `_.set('MC.玩家.职位', '科员', '主任科员');`
        - 更新玩家部门:
          `_.set('MC.玩家.部门', '综合管理科', '行动一科');`

  format: |-
    <UpdateVariable>
        //${原因说明}
        _.set('${路径}', ${旧值}?, ${新值});
        //${原因说明}
        _.assign('${路径}', ${键}?, ${值});
        //${原因说明}
        _.remove('${路径}', ${键}?);
        //${原因说明}
        _.add('${路径}', ${增量});
    </UpdateVariable>

  example: |-
    <UpdateVariable>
        // 时间推进2小时（从09:30到11:30）
        _.set('MC.系统.当前时间.时间', '09:30', '11:30');
        
        // 地点转移到会议室
        _.set('MC.系统.当前地点', '综合管理科办公室', '大会议室');
        
        // 玩家职位晋升
        _.set('MC.玩家.职位', '科员', '主任科员');
        
        // 添加新出场人物到花名册（正确：一次性创建完整条目，键名不含点号）
        _.assign('MC.花名册.entries', 'No004', {
          "id": "No004",
          "name": "李雨薇",
          "gender": "女",
          "age": 22,
          "department": "技术支援科",
          "position": "技术员",
          "rank": "科员",
          "yearsOfService": 1
        });
        
        // 更新已存在人员的单个字段（正确：No001 已存在于数据中，字段也已存在）
        _.set('MC.花名册.entries.No001.notes', '行动一科负责人。', '行动一科负责人，今日主持了部门会议。');
        
        // 🚨为已存在人员添加新字段（正确方法：用 assign 覆盖整个条目，包含所有原字段+新字段）
        _.assign('MC.花名册.entries', 'No001', {
          "id": "No001",
          "name": "沈凌汐",
          "gender": "女",
          "age": 27,
          "department": "行动一科",
          "position": "科长",
          "rank": "管理层",
          "yearsOfService": 5,
          "appearance": "...",
          "figure": "...",
          "attire": "...",
          "personality": ["严厉", "一丝不苟"],
          "rating": "S级",
          "notes": "行动一科负责人，今日主持了部门会议。",
          "specialSkill": "格斗技巧"
        });
        
        // 批量更新条目的多个字段（正确：使用 assign 覆盖整个条目，包含所有字段）
        _.assign('MC.花名册.entries', 'No002', {
          "id": "No002",
          "name": "苏淼雨",
          "gender": "女",
          "age": 24,
          "department": "综合管理科",
          "position": "文员",
          "rank": "科员",
          "notes": "今日表现优秀"
        });
        
        // 为花名册添加新字段定义
        _.assign('MC.花名册.$schema.fields', 'specialSkill', {
          "label": "特殊技能",
          "type": "text",
          "description": "人员的特殊技能描述",
          "order": 25
        });
        
        // 将新字段加入分组
        _.set('MC.花名册.$schema.groups.evaluation.fields', ["personality", "rating"], ["personality", "rating", "specialSkill"]);
        
        // 添加新文档
        _.assign('MC.文档', '培训手册', {
          "title": "培训手册",
          "description": "新员工培训指南",
          "order": 3,
          "sections": { "$meta": { "extensible": true } }
        });
        
        // 为新文档添加章节
        _.assign('MC.文档.培训手册.sections', '第一章', {
          "title": "第一章 入职须知",
          "content": "欢迎加入本处...",
          "order": 1,
          "children": { "$meta": { "extensible": true } }
        });
    </UpdateVariable>

  ## ⚠️ 错误示例（以下写法会导致运行时错误）
  
  ```javascript
  // ❌ 错误1：用 _.set 更新整个条目（最常见错误！）
  _.set('MC.花名册.entries.No001', {...}, {...});  // 如果 No001 不存在，会报 "path does not exist"
  
  // ✅ 正确：应该用 _.assign，路径到 entries
  _.assign('MC.花名册.entries', 'No001', { 完整的条目对象 });
  
  // ❌ 错误2：对不存在的条目逐个添加字段
  _.assign('MC.花名册.entries.No999', 'name', '张三');  // No999 不存在，会报错
  _.assign('MC.花名册.entries.No999', 'age', 25);       // 同样会失败
  
  // ✅ 正确：应该一次性创建完整条目
  _.assign('MC.花名册.entries', 'No999', {"id":"No999","name":"张三","age":25});
  
  // ❌ 错误3：对不存在的路径使用 set 修改字段
  _.set('MC.花名册.entries.No999.name', null, '张三');  // No999 不存在
  
  // ❌ 错误4：假设条目存在而直接修改字段
  _.set('MC.花名册.entries.No888.position', '科员', '主任');  // 如果 No888 不存在会失败
  
  // ❌ 错误5：键名包含点号（最危险的错误！）
  _.assign('MC.花名册.entries', 'No.001', {...});  // 点号会破坏路径解析！
  _.set('MC.花名册.entries.No.001.name', ...);     // 路径会被错误分割！
  
  // ❌ 错误6：向已存在的条目直接添加新字段（会报 SCHEMA VIOLATION！）
  _.assign('MC.花名册.entries.No001', 'bust', '...');    // MVU schema 验证会拒绝！
  _.assign('MC.花名册.entries.No001', 'waist', '...');   // 同样会报错！
  
  // ✅ 正确：必须用 _.assign 覆盖整个条目对象
  _.assign('MC.花名册.entries', 'No001', { ...所有原字段, bust: '...', waist: '...' });
  ```
  
  ### 🔑 记住这两条核心规则
  
  **规则1：键名不能包含点号（.）**
  ```javascript
  // ❌ 错误
  _.assign('MC.花名册.entries', 'No.001', {...});
  // ✅ 正确
  _.assign('MC.花名册.entries', 'No001', {...});
  ```
  
  **规则2：要创建或覆盖 entries 下的条目，必须用 _.assign**：
  ```javascript
  _.assign('MC.花名册.entries', '条目ID', { ... });  // 路径到 entries，键名是条目ID（不含点号）
  ```
  
  **不要用**：
  ```javascript
  _.set('MC.花名册.entries.条目ID', ..., { ... });   // 这样会报错！
  ```

</变量更新规则>